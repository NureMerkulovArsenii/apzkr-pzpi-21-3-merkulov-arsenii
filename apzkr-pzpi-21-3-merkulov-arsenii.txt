Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
 
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації роботи готелю 

Студент гр. ПЗПІ-21-3 		__________________ Меркулов А.В.
(підпис)

Керівник роботи 			__________________ доц. Лещинська І.О.
(підпис)

Роботу захищено «__»_________2024 р.
з оцінкою _________________________

Комісія: 				__________________ доц. Лещинська І.О.
(підпис)
__________________ доц. Лещинський В.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)
 
Харків 2024 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук                           Кафедра програмної інженерії     
Спеціальність 121 – Інженерія програмного забезпечення 			          
Курс                   3                   Семестр                                  6                                       
Навчальна дисципліна Архітектура програмного забезпечення                          

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                            Меркулову Арсенію Владиславович                              
1. Тема роботи: «Програмна система для автоматизації роботи готелю» – HospitalityHub
2. Термін узгодження завдання курсової роботи «19»    лютого     2024 р.
3. Термін здачі студентом закінченої роботи «15»    червня     2024 р.
4. Вихідні дані до проекту (роботи): У програмній системі передбачити: аутентифікацію та авторизацію користувачів, реєстрацію нових акаунтів для працівників готелю, редагування, додавання та видалення в системі інформації про готелі, кімнати, місця в кімнатах, персонал, клієнтів; бронювання кімнат та функціонал для реєстрації прибуття та від’їзду гостей; функціонал для створення, редагування та видалення завдань для персоналу. управління ролями, та доступом до функціоналу для кожної ролі. Використовувати ОС Windows 10 або 11, систему управління базами даних PostgreSQL 16.2, контейнери Docker та контейнеризатор Docker Desktop, редактор коду Visual Studio Code, середовище розробки Microsoft Visual Studio 2022 та JetBrains Rider, мови програмування C#, TypeScript та  C++, а також фреймворки ASP.NET Core 8.0 для серверної частини і Angular 16 для клієнтської частини. 					
 
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, аналіз предметної області, постановка задачі, концепція та рамки проекту, проектування та реалізація серверної частини, інтернету речей та веб-клієнту, висновки, перелік посилань, додатки.				
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
Deployment Diagram, Use Case Diagram, ER-модель даних, Component Diagram, Package Diagram, Interaction Overview Diagram, Activity Diagram, інтерфейс сторінки списку персоналу, інтерфейс сторінки управління персоналом та його задачами	.							
 
КАЛЕНДАРНИЙ ПЛАН

№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	29.02.2024	виконано
2	Проектування програмного
проекту	08.03.2024	виконано
3	Кодування програмного проекту	13.05.2024	виконано
4	Оформлення пояснювальної
записки	31.05.2024	виконано
5	Захист курсової роботи	29.06.2024	виконано

Дата видачі теми проекту «4» березня 2024 р.  
 

Керівник				______________ доц. Лещинська І.О.
(підпис)


Завдання прийняв до виконання 
ст. гр. ПЗПІ-21-3 	 	 	 			 Меркулов А.В. 
(підпис)


 
РЕФЕРАТ

Пояснювальна записка до курсової роботи: 84 с., 14 рис., 3 табл., 9 додатків, 6 джерел.
БРОНЮВАННЯ КІМНАТ В ГОТЕЛІ, ПЕРСОНАЛ, КОРИСТУВАЧ, ЗАДАЧІ ПЕРСОНАЛА, РОЗПОДІЛЕННЯ ДОСТУПУ, РЕЗЕРВНА КОПІЯ БАЗИ ДАНИХ, ГОТЕЛЬ, УПРАВЛІННЯ КОРИСТУВАЧАМИ.
Об’єктом дослідження цієї роботи виступає сфера організації роботи і управління готелю, як мережі готелів, так  і окремих гостинних дворів. Загалом цей процес є доволі  складним [1], бо задля успішної роботи потрібно брати до уваги багато факторів: управління персоналом, бронювання номерів, планування робіт і оновлення інвентарю, розподілення доступу до функцій системи тощо. 
Тож метою роботи є розробка програмної системи для управління роботою готелю. Дана система спростить роботу для менеджерів і обслуговуючого персоналу готелю і дасть змогу автоматизувати багато процесів. Дана система дозволяє виконувати налаштування інформації про готелі, номери в готелях, місця в номерах, персонал готелю, а також відслідковувати задачі для персоналу, клієнтів та виконувати бронювання номерів.
Методами розробки включають наступі технології: для розробки серверної частини програмної системи обрано мову C#, платформу .NET 8 і фреймворк ASP.NET Web API, в якості СУБД обрано PostgreSQL 16.2. Для розробки клієнтської веб-частини обрано фреймворк Angular 16 та мову програмування TypeScript. Для виконання IOT частини системи обрано плату ESP 32 та мову програмування C++.
У результаті розробки створено систему, що дозволяє керувати готелем, робити бронювання, керувати персоналом та їх задачами, розподіляти доступи до системи. Ця програмна система складається із 3 компонентів: серверної частини, клієнтської частини та ІоТ пристрою.
 
ЗМІСТ
ЗМІСТ	6
ВСТУП	9
1 БІЗНЕС-ВИМОГИ	11
1.1 Передумови	11
1.2 Business Opportunities (Бізнес-можливості)	12
1.3 Бізнес-цілі та критерії успіху	13
1.4 Потреби клієнтів та ринку	15
1.5 Бізнес-ризики	15
2. КОНЦЕПЦІЯ РІШЕННЯ	18
2.1 Окреслення концепції	18
2.2 Головна функціональність	19
2.3 Припущення та залежності	19
3 РАМКИ ТА ОБМЕЖЕННЯ	21
3.1 Рамки первинного випуску	21
3.2 Рамки наступних випусків	22
3.3 Обмеження та винятки	22
4 БІЗНЕС-КОНТЕКСТ	24
4.1 Профілі зацікавлених сторін	24
4.2 Пріоритети проекту	25
4.3 Робоче середовище	25
5 СЕРВЕРНА ЧАСТИНА	27
5.1 Опис прийнятих інженерних рішень	27
5.2 Діаграми	28
5.3 Специфікація REST	33
5.4 Опис частин програмного коду	37
5.4.1 Реєстрація залежностей (Dependency Injections)	37
5.4.2 Аутентифікація та Авторизація	39
5.4.3 Робота з відправкою повідомлень на пошту	40
5.4.4  Робота з базою даних та транзакціями	41
5.4.5  Локалізація	42
5.4.6 Глобальний обробник помилок	43
6 ІОТ ПРИСТРІЙ	44
6.1 Опис прийнятих інженерних рішень	44
6.2 Діаграми	45
6.3 Пояснення програмного коду	47
6.3.1 Аутентифікація	47
6.3.2 Робота з сервомотором та світлодіодом	48
6.3.3 Робота з клавіатурою для введення цифр (Keypad)	48
7 КЛІЄНТСЬКА ЧАСТИНА	51
7.1 Опис прийнятих інженерних рішень	51
7.2 Діаграми	52
7.3 Опис частин програмного коду	55
7.3.1 Реєстрація залежностей (Dependency Injections)	55
7.3.2 Аутентифікація та Авторизація	56
7.3.3 Локалізація	57
ВИСНОВКИ	58
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	60
ДОДАТОК А	61
ДОДАТОК Б	62
ДОДАТОК В	66
ДОДАТОК Г	68
ДОДАТОК Ґ	74
ДОДАТОК Д	78
ДОДАТОК Е	79
ДОДАТОК Є	81
ДОДАТОК Ж	82
ДОДАТОК З	83
 
ВСТУП

Готельний бізнес відіграє важливу роль в економіці багатьох країн, демонструючи постійний розвиток та адаптацію до нових умов. Сучасні готелі стикаються з численними викликами, такими як коливання попиту та змінні очікування гостей, висока конкуренція на ринку, а також необхідність ефективного управління ресурсами. Великі готельні мережі мають можливість розробляти та впроваджувати власні системи управління, які значно покращують їхні операційні процеси. Водночас, для малих та середніх готелів подібні рішення часто залишаються недоступними через високу вартість та складність реалізації. Впровадження автоматизованих систем управління могло б значно оптимізувати витрати та підвищити прибутковість цих закладів.
Однією з основних проблем, з якими стикаються готелі, є ефективне управління бронюванням та максимізація доходів від доступних ресурсів. Традиційні методи, які використовуються для управління готельним бізнесом, часто виявляються обмеженими та неефективними в умовах сучасного ринку, що вимагає швидкої адаптації до змінних умов та запитів клієнтів. Таким чином, актуальність впровадження програмного забезпечення для автоматизації готельних процесів стає очевидною, відкриваючи нові можливості для підвищення ефективності та конкурентоспроможності готелів.
Метою даної курсової роботи є розробка програмної системи для автоматизованого управління готелями. Ця система повинна забезпечувати засоби для моніторингу стану номерного фонду, ефективного адміністрування і обліку готелю та управління персоналом та його задачами, а також аналізу даних для оптимізації управлінських процесів. Використання такої системи сприятиме підвищенню ефективності роботи готелів, покращенню якості обслуговування та зниженню операційних витрат.
Під час виконання роботи буде проведено аналіз існуючих рішень на ринку, визначено ключові вимоги до програмного забезпечення, розроблено архітектуру та реалізовано відповідну систему. Також буде здійснено тестування розробленої системи для перевірки її функціональності та ефективності.
Таким чином, ця курсова робота має на меті зробити значний внесок у розвиток інформаційних технологій у сфері готельного бізнесу та сприяти підвищенню конкурентоспроможності готелів на ринку.
 
1 БІЗНЕС-ВИМОГИ

1.1	Передумови

Функціонування готельної галузі є важливим елементом господарства в багатьох країнах, і вона постійно розвивається. Сучасні готелі стикаються з рядом викликів, таких як зміни в попиті та очікуваннях гостей, конкуренція на ринку, а також потреба в ефективному управлінні ресурсами. Великі готельні мережі розробляють власні системи готельного менеджменту, проте дані розробка подібних систем є недоступною для малих та середніх готелів, проте автоматизація багатьох процесів за допомогою подібної системи значно допомогла б оптимізувати витрати та збільшити прибутковість [1].
Насамперед, початковою проблемою є питання ефективного управління обсягами бронювання та забезпеченням максимальної виручки від доступних ресурсів. Традиційні методи управління готельним бізнесом можуть бути обмеженими та неефективними в умовах сучасного ринку.
Другою проблемою, яку ми вирішуємо, є необхідність забезпечення високої якості обслуговування для гостей та оптимізація робочих процесів. Нестача автоматизації та оптимізації може призводити до незадовільного досвіду гостей та втрати конкурентоспроможності на ринку.
Третьою проблемою є необхідність ефективного управління персоналом та ресурсами готелю. Традиційні підходи можуть бути часо- та ресурсозатратними, що призводить до зайвих витрат та погіршання ефективності діяльності готелю.
Даний перспективний продукт стане цікавим як і невеликими так і середнім готельним мережам.
 
1.2	Business Opportunities (Бізнес-можливості)

На ринку вже певний час присутні системи які мають виконувати подібні функціональні задачі. Основними конкурентами стануть українська компанія «Expert Solution», яка займається автоматизацією різноманітними процесів пов’язаних з готельними та ресторанним бізнесами, компанія має значну кількість партнерів на ринку та велику кількість інших послуг та досвід з впровадження таких систем. Також конкурентами на даному ринку стане компанія «jSolutions», яка також займається системами автоматизованого управління для готелів, хостелів та пансіонатів. Компанія має повноцінну систему продуктів, які можуть забезпечити повний цикл контролю над різними аспектами роботи готелю. Проте наш продукт має всі шанси зайняти власну нішу на ринку за рахунок ключових переваг:
1)	Інтеграція різноманітних сторонніх систем та різних варіантів замків та інших датчиків, що надають інформацію про наповненість готелю та надають гостям безпечний сервіс. Також можливість використання системи для різних умов, таких як малі та середні мережі готелів, хостели, пансіонати та кемпінги, також гнучка конфігурація системи з різними рівнями доступу до функцій та зміни налаштувань.
2)	Автоматизація рутинних завдань: Наша система автоматизує багато рутинних завдань управління готелем, таких як обробка платежів, виписка рахунків та звітності. Це дозволяє персоналу готелю сконцентруватися на наданні якісного обслуговування гостям.
3)	Збір статистики та аналітики, щодо функціонування системи, кількості задіяного інвентарю та можливість відстеження виконання роботи працівниками, що дозволить робити висновки та вносити корективи до роботи системи, а також відслідковувати стан виконання робіт.
4)	Основною перевагою стане гнучкість та можливість швидко підлаштовуватись, масштабуватись і вирішувати задачі клієнтів, а також доступність встановлення та підтримки працездатності системи.
Модель монетизації передбачає наступні статті доходу:
а)	Початковий платіж за встановлення та налаштування системи замків, сервісів та  та автоматичних лійок, можливі різні конфігурації за різними цінами;
б)	Підписка на обслуговування обладнання, технічну підтримку системи онлайн або з фізичною присутністю фахівців, в залежності від пакету підписки та технічної несправності. Підписка на отримання певного функціоналу системи та доступу до різних аналітичних даних від сенсорів.
в)	Партнерські програми з компаніями представника обладнання для туристичного сектору економіки, заради зниження цін на обладнання.

1.3	Бізнес-цілі та критерії успіху

Бізнес-цілі:
ВО-1: Забезпечення підвищення ефективності малих і середніх мереж готелів за рахунок автоматизації бізнес процесів та надання якісного сервісу рівня елітних готелів.
ВО-2: Отримання виручки від продажу систем в розмірі 20-28% від початкових вкладень за перший рік.
ВО-3: Запустити систему у 10 готелях або мережах за перший рік роботи. Готелі або мережі готелів різної величини та складності впровадження для тестування продукту на реальних проектах, та початку отримання фінансової вигоди.
BO-4: Максимізація використання готельних ресурсів, таких як доступні номери, персонал і послуги, для забезпечення більшої ефективності та прибутковості.
BO-5: Реалізація системи, яка допомагає готелю забезпечувати вчасне та якісне обслуговування гостей, включаючи швидке заселення, вибір кімнати та інші послуги.
ВО-6: Укласти партнерські контракти з 2 мережами готелів в Україні на встановлення системи автоматизовано управління готелем.

Критерії успіху:
SC-1: Збільшення обсягу бронювання на 20% протягом першого року використання системи..
SC-2: Підвищення середньої оцінки готелю на популярних веб-сайтах бронювання на 0,5 бали протягом перших 6 місяців впровадження.
SC-3: Зменшення часу заселення гостей на 15% за перші 3 місяці використання системи.
SC-4: Підвищення загального доходу готелю на 15% за перший рік використання системи.
SC-5: Використання готельних ресурсів на 90% або більше протягом кожного місяця.
SC-5: Успіх системи полягатиме у можливості впровадження її на різних готелях та можливості розширення її функціональності та сумісності з іншими спорідненими системами в майбутньому.
SC-6: Система повинна стати затребуваним і зручним інструментом для менеджменту бронювання, управління персоналом, надання послуг клієнтам, фінансової аналітики для менеджерів, бухгалтерів та аналітиків.



1.4	Потреби клієнтів та ринку

CN-1: Клієнти очікують, що система, дозволить їм ефективно управляти всіма аспектами їхнього готелю, включаючи бронювання, фінанси, управління персоналом та звітність.
CN-2: Клієнти хочуть мати систему, яка допомагає максимізувати виручку готелю шляхом оптимізації цін, управління запасами та зниження витрат на операції.
CN-3: Власники готелів та менеджери можуть шукати програмну систему, яка надає аналітичні звіти та інструменти прогнозування, щоб допомогти їм приймати обґрунтовані рішення щодо стратегії розвитку готелю.
CN-4: Управлінці потребують систему, яка буде допомагати керувати персоналом та організовувати їх задачі.
CN-5: Клієнти бажають мати доступ до технічної підтримки користувачів та навчання з використання системи.
CN-6: Клієнти бажають, щоб система була сумісною з існуючими обладнаннями та сторонніми системами та могла бути легко розширена у майбутньому.
CN-7: Власники готелів та менеджери покладають великий акцент на безпеку та конфіденційність даних своїх гостей, тому очікують, що система гарантуватиме їх захист.

1.5	Бізнес-ризики

Бізнес-ризики:
BR-1: Розробка та впровадження нової технології може бути пов'язана з технічними труднощами та невизначеністю. Наприклад, можуть виникнути проблеми зі сумісністю з різними видами обладнання або з надійністю системи.
Заради запобігання таким небажаним проблемам, слід на етапі проектування визначити спектр можливих сторонніх систем і датчиків, які будуть інтегровані в наш продукт та є затребуваними на ринку.
BR-2: Існує можливість конкуренції з іншими розробниками або постачальниками подібних систем для готелів. Важливо розробити конкурентоспроможну систему і стратегію маркетингу.
Для вирішення цієї проблеми слід чітко визначити свій ринок та цільову аудиторію, врахувати спроможності конкурентів та їх системи та об’єктивно оцінити власні можливості та платоспроможність цільової аудиторії.
BR-3: Проект вимагатиме фінансових вкладень на етапі розробки та впровадження. Недостатні фінансові ресурси або перевищення бюджету можуть вплинути на успішність проекту.
Задля уникнення даної проблеми потрібно заздалегідь оцінити всі можливі витрати по проекту та виділити резервні кошти на непередбачувані витрати.
BR-4: Рівень попиту на системи керування годілянтелями може змінюватися в залежності від факторів, таких як фінансова стабільність країни, безпека, військова ситуація.
Щоб уникнути цієї проблеми слід проконсультуватися з власниками і менеджерами та іншими кінцевими клієнтами, щоб отримати відгуки та рекомендації з перших рук.
BR-5: Зміни у законодавстві та регуляційних документах, такі як нові правила щодо захисту особистих даних або оподаткування, можуть вплинути на бізнес-модель і рентабельність готельної системи. Попередити цю проблему дозволить консультація з фаховими юристами та фінансистами, що теж варто включити в статтю розходів.
BR-6: Збір та зберігання даних про гостей, персонал, фінансову звітність готельної системи може стати об'єктом кібератак або порушень конфіденційності даних. Необхідно приділити належну увагу заходам забезпечення і захисту даних.
Проектування захищеної системи з консультаціями або наймом фахівців з кібербезпеки допоможе значно посилити захист системи та ускладнити або позбавити бажання зловмисників заподіювати шкоду.
Оцінка бізнес-ризиків та розробка стратегій для їх управління та мінімізації є ключовими етапами для зменшення можливих негативних впливів та забезпечення стабільності проекту.

 
2. КОНЦЕПЦІЯ РІШЕННЯ

2.1	Окреслення концепції

Мета проекту полягає у розробці програмного рішення, яке спрямоване на покращення ефективності, зручності та якості обслуговування в готельній галузі. Ми прагнемо створити інтегровану платформу, що об'єднує в собі функції бронювання, обліку ресурсів, управління персоналом та аналітики, що дозволить готелям оптимізувати свою діяльність та забезпечити найвищий рівень задоволення для своїх гостей.
Система має бути надійною, ефективною та економічно доступною, а також мати велику кількістю інтеграцій. Продукт спроможний інтегрувати наявні технології на ринку в одну єдину систему, що матиме попит як серед великих корпорацій, так і серед невеликих пансіонатів, хостелів та мереж готелів середніх розмірів. Це досягається завдяки інтеграції системи з існуючим обладнанням, що гарантує відносно низькі витрати на впровадження системи, а також завдяки наявності різноманітних конфігурацій та тарифних планів.
Ця система базується на концепції об'єднання технологій Інтернету Речей (Internet of Things, IoT), серверного рішення для збору даних, системи аналітики та представлення даних, а також функцій для управління системою. Важливими складовими цього рішення є мобільні та веб-інтерфейси для відслідковування стану системи, налаштувань та зміни конфігурації і управління персоналом.
Окрім цього, ефективне впровадження цієї системи передбачає наявність служби технічної підтримки, яка зможе навчити клієнтів правильному та ефективному використанню системи. Служба  буде відповідальною за вирішення технічних питань, пов'язаних з можливими збоями, виявленням помилок та відновленням роботи обладнання.
2.2	Головна функціональність

Головна функціональність:
МF-1: Аутентифікація та авторизація користувачів надає можливості користувачам використовувати різні тарифні плани системи та розподіляти права доступу до функцій системи.
МF-2: Система використовує технологій Інтернету Речей (IoT) яка забезпечує інтеграцію з сенсорами та замками для керування доступом до номерів та отримання інформації щодо заселення готелю.
МF-3: Модуль бронювання, який дозволить приймати онлайн-бронювання через веб-сайт. Управління доступністю номерів та їх категоріями та автоматичне оновлення інформації про бронювання та заборону недійсних карток.
МF-4: Управління персоналом та розкладами з можливістю розподілення задач між працівниками.
МF-5: Формування статистики використання системи враховуючи історію даних для аналізу роботи та коригування її параметрів.
МF-6: Система тарифних планів які будуть відповідати за надання інформації з певних датчиків та доступ до різних режимів роботи системи.
МF-7: Застосунок для персоналу для відстеження поточних задач.

2.3	Припущення та залежності

Припущення:
AS-1: Доступ до інтернету - припускається, що на локації готелю присутнє стабільне інтернет-з'єднання для взаємодії з програмною системою та для доступу гостей до онлайн-сервісів.
AS-2: Можливість встановлення сенсорів та обладнання - припускається, що користувачі зможуть встановити необхідні сенсори та обладнання на своїх полях самостійно або за допомогою служби технічної підтримки.
AS-3: Знання персоналу - припускається, що персонал готелю має базові навички роботи з комп'ютером та мобільними пристроями для користування системою.
AS-5: Наявність комп'ютерів або мобільних пристроїв - припускається, що персонал готелю та гості мають доступ до комп'ютерів або мобільних пристроїв для взаємодії з програмною системою.
AS-4: Інтеграція з вже існуючим обладнанням - припускається, що систему можна буде підключити до вже встановлених замків та інших датчиків.
Залежності:
DP-1: Залежність від зовнішніх сервісів - успішна робота системи може залежати від доступності та стабільності зовнішніх сервісів, таких як сервіси онлайн-бронювання, платіжні шлюзи, системи аналітики тощо.
DP-2: Інтеграція з різними типами готельного обладнання - система може залежати від успішної інтеграції з різними типами готельного обладнання, такими як системи контролю доступу, POS-термінали, системи кондиціювання повітря тощо.
DP-3: Доступність програмного забезпечення та технологічних платформ - використання певних програмних засобів і технологічних платформ може впливати на розробку системи.
DP-4: Система може залежати від успішної інтеграції з бухгалтерськими та аналітичними системами для ведення фінансового обліку та аналізу бізнесу.
 
3 РАМКИ ТА ОБМЕЖЕННЯ

3.1 Рамки первинного випуску

Перша версія системи буде спрямована на демонстрацію концепції продукту та створення мінімально працездатної версії продукту (MVP). Для цього необхідно забезпечити можливість системи виконувати основні свої функції. Наведемо основну функціональність, яку необхідно реалізувати для первинного випуски продукту:
Серверна частина: 
•	аутентифікація та авторизація користувачів, розподілення  ролей для контролю доступу до функцій системи;
•	можливість прийняття, збереження, оновлення та видалення бронювання готельних номерів через API.;
•	формування звітів статистики використання системи;
•	відслідковування доступності номерів та оновлення інвентарю в реальному часі;
•	видача задач для персоналу;
•	захисту конфіденційності та цілісності даних користувачів.
Клієнтська частина (веб сайт та мобільний застосунок): 
•	відображення поточного стану системи;
•	аутентифікація та авторизація користувачів;
•	відображення бронювання номерів на майбутній період;
•	відображення налаштувань системи та можливість їх зміни;
•	відображення статистики заселення та виконання задач персоналом.
Інтернет речей (IoT):
•	замки на дверях для відстеження зайнятості номерів.
•	передача даних здійснюється через мережевий модуль;
3.2 Рамки наступних випусків

У наступних релізах системи необхідно розширити функціональність продукту для підвищення ефективності та економності системи, також необхідно додати інтеграції з іншими системами, які є наявними у готелях, наприклад з рестораном.
Розширені аналітичні засоби - розвиток аналітичних інструментів для надання користувачам більш докладного аналізу даних про заселення номерів, бронювання, прибуток та інші аспекти готельного бізнесу.
Розширення можливостей передбачення - розробка алгоритмів передбачення наповненості та прибутковості готелю для надання користувачам інструментів для ефективного планування.

3.3 Обмеження та винятки

Обмеження:
L-1: Обмеження доступності інтернет-з'єднання - програмна система може бути обмеженою в своїй працездатності в разі відсутності стабільного інтернет-з'єднання на локації готелю. Це може вплинути на можливість користувачів взаємодіяти з системою, а також на її здатність надавати онлайн-сервіси для гостей.
L-2: Наявність готельного обладнання - програмна система може бути обмеженою в своїй функціональності в разі відсутності необхідного готельного обладнання, такого як комп'ютери або мобільні пристрої для користувачів, що може ускладнити її впровадження та ефективне використання.
L-3: Залежність від сторонніх постачальників послуг - програмна система може бути обмеженою в своїй працездатності в разі відмови сторонніх постачальників послуг, таких як сервіси онлайн-бронювання або платіжні шлюзи. Це може вплинути на здатність готелю приймати бронювання та проводити оплату через систему.
L-4: Технічні обмеження готельних мереж - програмна система може бути обмеженою в своїй функціональності в разі наявності обмежень у готельних мережах, таких як обмеження на кількість підключених пристроїв або швидкість інтернет-з'єднання. Це може вплинути на продуктивність та ефективність роботи системи.

Винятки:
E-1: Система не включає в себе управління будівельними аспектами готелю, такими як ремонтні роботи, обслуговування і технічне обслуговування приміщень.
E-2: Система не надає інструментів для управління персональними даними гостей у відповідності з регуляторними вимогами щодо конфіденційності та захисту даних, а також не включає функціонал для автоматизації процесів обробки особистої інформації.
 
4 БІЗНЕС-КОНТЕКСТ

4.1 Профілі зацікавлених сторін

Зацікавлені сторони	Основна цінність	Ставлення	Основні інтереси	Обмеження
Власники та управляючі готельних мереж	Ефективне та автоматизоване управління готельними процесами	Очікують покращення ефективності	Збільшення виробничої потужності, підвищення рівня обслуговування, зниження витрат	Обмеження в обсязі інвестицій та доступ до передових технологій
Інформаційні технології та програмні компанії	Постачання інноваційного програмного забезпечення для готельних мереж	Очікують розширення ринкових можливостей	Підвищення конкурентоспроможності, розвиток нових ринків, підтримка інноваційних проектів	Обмеження у фінансуванні та технічних ресурсах
Фінансові установи та інвестори	Інноваційний проект в сфері готельного бізнесу	Очікують на інвестування в перспективний проект та отримання фінансової вигоди	Отримання прибутку та підтримка інноваційних проектів у галузі	Обсяги інвестицій та ризики, пов’язані з реалізацією проекту
Гостьові та клієнти готельних мереж	Зручність та персоналізований сервіс	Очікують високого рівня обслуговування	Комфортне перебування, індивідуальний підхід, доступність послуг та зручність розрахунків	Обмеження в обслуговуванні під час пікових періодів та недостатня реакція на звернення гостей

 
4.2 Пріоритети проекту

Область
	Мета	Обмеження	Припустимий стан
Часовий графік	Випуск MVP версії до 01.05.2023	Непередбачувані життєві або технологічні обставини	Реліз MVP версії продукту до 10.05.2024
Функціональна складова	Реалізація 55-65% функціоналу системи	Обмежений час на розробку програмної системи	Основні функції будуть розроблені у першій версії
Якість	Функціональна стабільність, відсутність критичних помилок та працездатність системи	Обмежений час на тестування та розробку, відсутність повноцінної команди для проведення повноцінного тестування	Наявність не критичних помилок, які відтворюються лише в рідкісних сценаріях та не заважають виконанню системою основних функцій
Персонал	Команда складається з одного розробника	Усі етапи створення продукту залежать від 1 людини	Достатній рівень знання і розуміння усіх етапів розробки програмного забезпечення
Бюджет	Загальний бюджет розробки $34000, витрати на MVP версію $4000	Підвищення цін на стороннє обладнання та на хмарні хостинги	Перевищення бюджетних витрат по проекту на 8% є прийнятним та не потребує перегляду бізнес плану.

4.3 Робоче середовище

Наш проект передбачає використання сучасних та ефективних технологій побудови апаратної та програмної частин системи. Проект передбачає наявність серверної частини, клієнтської частини та інтернету речей (IoT):


1)	Серверна частина:
За основу систему взято платформу .NET 8 та як фреймворк для серверного API (Application Programming Interface) використано ASP.NET, який буде керувати системою та надавати доступ клієнтським частинам до даних системи. В проекті будуть використані бібліотеки: Entity Framework Core 8, Serilog, Mapster, Autofac та ін.
Для зберігання даних будемо використовувати реляційну базу даних PostgreSQL 14.7, яка надає надійний та захищений доступ до даних.
2)	Клієнтська частина:
Мобільний застосунок написаний на Java під платформу Android, що дозволить швидко розробити дану клієнтську частину орієнтовану на управління персоналом. Для локального кешу буде використано базу даних SqlLite.
Веб сайт, що дозволить керувати системою з комп’ютера та мати доступ до більшої кількості інформації та функцій продукту. Для розробки даної частини системи буде використано надійний та перевірений фреймворк Angular 17. А мову програмування обрано TypeScript. В проекті будуть використані бібліотеки: Bootstrap 5, Angular Material, RxJS та ін.
3)	Інтернет речей (IoT): 
Для збору даних із сенсорів та для керування контролерами буде використано платформу мікроконтролер ESP32. Для написання коду під дану платформу будемо використовувати VS Code та для симуляції роботи системи Platform IO та Wokwi. Мовою програмування обрано C++.
4)	Розгортання клієнтської системи буде відбуватись за допомогою проксі-серверу nginх. Серверна частина буде розгортатись локально під управлінням Docker. База даних PostgreSQL буде розгорнута в Docker контейнері.
 
5 СЕРВЕРНА ЧАСТИНА

5.1	Опис прийнятих інженерних рішень

Серверна частина проекту розроблена на платформі .NET 8 з використанням мови C#. API створено засобами фреймворку ASP.NET Core 8. Системою управління бази даних (далі СУБД) для проекту обрано PostgreSQL 16.2. Для роботи з базою даних (далі БД) використано Entity Framework Core 8, а також використано підхід Code First, який дозволяє в коді створити сутності бази даних у вигляді класів та інших типів, а потім за допомого міграцій перетворити їх на таблиці в БД. Аутентифікацію та авторизацію на проекті реалізовано за допомогою вбудованих можливостей в ASP.NET Core, а саме бібліотеки ASP.NET Core Identity. Ця бібліотека дозволяє швидко та гнучко налаштувати авторизацію, а також надає весь необхідний функціонал який підходить для більшості подібних систем. Механізми аутентифікації основані на токені доступу, який передається в заголовку кожного запиту та токені оновлення, що знаходиться в HTTP-Only Cookie. Токен оновлення зберігається в базі даних використовується для оновлення токену доступу, який має невеликий період життя.
Серверна частина має монолітну багатошарову архітектуру, що складається з 3 шарів: шар представлення даних, шар бізнес-логіки та шар доступу до даних. Також окремо виділені збірки з проксі для зовнішніх сервісів, а також наявні окремі збірки для моделей, контрактів та локалізації. Логіку бізнес шару реалізовано за допомогою підходу окремих обробників операцій (Handlers),  кожна одиниця бізнес-логіки міститься в окремому обробнику, такий підхід на початкових етапах проекту може бути надлишковим, проте він надає на майбутнє можливість розділяти бізнес-логіку, і вирішує майбутню проблему надвеликих сервісів, які мають тенденцію розростатись, коли межі розділення відповідальності між логікою стають розмиті. Шар доступу до даних представлений  контекстом БД який являє собою абстракцію над БД для зручного доступу до даних, написання запитів, та управління транзакціями. Над даною абстракцією реалізовано обгортку, з шаблону «Універсальний Репозиторій» (GenericRepository) [2], який абстрагує нашу бізнес-логіку від доступу до даних, так як в разі переходу на інший провайдер даних, наприклад MongoDB, контекст бази даних буде змінено, отже в такому випадку нам доведеться централізовано змінити один клас, при чому інтерфейс залишиться старим, або буде доповнено новим функціоналом. Також застосовується шаблон «Одиниця роботи» (Unit of Work), який буде керувати транзакціями в БД. Для оптимізованого доступу до даних використовується ліниве завантаження (Lazy Loading), що дозволяє на рівні бізнес логіки обирати дані які нам необхідно завантажити, і в який саме момент. Описаний підхід дозволяє оптимізувати запити в БД під потреби та обмеження інфраструктури та бізнес-логіки. Як згадано вище, в якості С обрано PostgreSQL, що є дешевим, перевіреним рішенням з відкритим початковим кодом. Дана СУБД повністю покриває початкові і майбутні потреби проекту і є широко використана, як для малих проектів, так і для великих ентерпрайз рішень.

5.2	Діаграми

ER-модель даних проекту (рис. 5.1) містить 15 сутностей, серед яких: AspNetRoleClaims, AspNetRoles, AspNetUserClaims, AspNetUserLogins, AspNetUserRoles, AspNetUsers, AspNetUserTokens, Booking, Customer, Hotel, Photo, Room, RoomPlace, Staff, TodoTasks. AspNetUsers: Це основна сутність, що представляє користувача в системі. Вона має відносини з багатьма іншими сутностями. AspNetRoles: Ця сутність представляє ролі, які може мати користувач. Є відношення багато-до-багатьох між AspNetUsers і AspNetRoles через сутність AspNetUserRoles. AspNetUserRoles: Ця сутність представляє призначення ролей користувачам. Вона має відношення багато-до-одного як з AspNetUsers, так і з AspNetRoles. AspNetUserClaims, AspNetUserLogins, AspNetUserTokens: Ці сутності пов'язані з AspNetUsers і зберігають додаткову інформацію про користувача, таку як клейми, входи та токени. Booking: Ця сутність представляє бронювання, зроблене клієнтом. Вона має відношення багато-до-одного з AspNetUsers (користувач може мати багато бронювань) і Room (кімната може мати багато бронювань). Customer: Ця сутність представляє клієнта, який може робити бронювання. Вона має відношення один-до-одного з AspNetUsers. Hotel: Ця сутність представляє готель. Вона має відношення один-до-багатьох з Room (готель може мати багато кімнат).
Room: Ця сутність представляє кімнату в готелі. Вона має відношення один-до-багатьох з Booking (кімната може мати багато бронювань) і RoomPlace (кімната може мати багато місць). RoomPlace: Ця сутність представляє місце в кімнаті. Вона має відношення багато-до-одного з Room. Staff: Ця сутність представляє співробітника. Вона має відношення один-до-одного з AspNetUsers і один-до-багатьох з TodoTasks (співробітник може мати багато завдань). TodoTasks: Ця сутність представляє завдання, призначене співробітнику. Вона має відношення багато-до-одного з Staff.
 
 
Рисунок 5.1 – ER-модель даних програмної системи для керування роботою готелю

Наступною діаграмою є діаграма розгортання системи (рис. 5.2). Представлена вона двома основними компонентами: веб сервером та базою даних. Система розгортається в докер-контейнерах. Серверна частина має 2 контейнери: для серверної частини і для бази даних PostgreSQL:
 
 
Рисунок 5.2 – Діаграма розгортання системи для керування готелем

Наступним кроком будо складено Use-Case діаграму (рис. 5.3) для відображення можливих сценаріїв дій для користувачів системи. Передбачено, що система має 2 користувача: менеджер системи/співробітник готелю та адміністратора. Також варто зазначити, що в середині системи у різних користувачів крім адміністратора може бути різний доступ до різних функцій.
 
 
Рисунок 5.3 – Use-Case діаграма можливих сценаріїв використання системи для різних користувачів 

Далі пропоную ознайомитись з діаграмою пакетів (Package-Diagram), яка показує залежності різних шарів архітектури (рис. 4) та взаємодію компонентів. Точкою запуску програми є файл Program.cs, в якому виконується конфігурація DI-контейнера та конвеєра обробки запиту.
 
 
Рисунок 5.4 – Package Diagram, діаграма залежностей архітектури

5.3	Специфікація REST

До ознайомлення пропонується специфікація REST API в таблиці 1.
Таблиця 1 – Специфікація REST
Посилання 	Метод 	Опис 
/api/Account/ create-role	POST	Створити роль
/api/Account/assign-role	POST	Назначити роль користувачу
api/Account/delete-role	POST	Видалити роль з БД
/api/Account/remove-role	POST	Видалити роль у користувача
/api/Account/logout	GET	Вихід з системи
 
Продовження таблиці 1
/api/Account/update-profile	GET	Оновити інформацію про номер телефону та ім’я та прізвище користувача
/api/Account/confirmEmail?userId={userId}&code={code}&changedEmail={changedEmail}	GET	Підтвердити зміну пошту
/api/Account/forgotPassword	POST	Отримати лінк на оновлення пароля
/api/Account/login?useCookies={useCookies}&useSessionCookies={useSessionCookies}	POST	Увійти в свій обліковий запис
api/Account/manage/2fa	POST	Включити/пройти двофакторну аутентифікацію
/api/Account/manage/info	GET	Отримати інформацію 
/api/Account/manage/info	POST	Внести інформацію
/api/Account/refresh	POST	Отримати новий токен доступу по токену оновлення
/api/Account/register	POST	Зареєструватися
/api/Account/resendConfirmationEmail	POST	Надіслати лист на пошту з посиланням для підтвердження пошти
/api/Account/resetPassword	POST	Оновити пароль
/api/Booking/cancel/:id	DELETE	Скасувати бронювання
 
Продовження таблиці 1
/api/Booking/checkin/:bookingId/code/:code	GET	Провести операцію реєстрації гостя
/api/Booking/checkout/:bookingId	GET	Провести операцію виїзду гостя з готелю
/api/Booking/create	POST	Забронювати кімнату в готелі
/api/Booking/filter?request= {request}	GET	Фільтрація бронювань
/api/Booking/update	PUT	Оновити інформацію по бронюванню
/api/Booking/:id	GET	Отримати інформацію по бронюванню
/api/DataAdministration/backup-db	POST	Створити бекап БД
/api/Hotel	GET	Отримати список готелів
/api/Hotel/create	POST	Створити готель
/api/Hotel/delete/:id	DELETE	Видалити готель
/api/Hotel/update/:id	PUT	Оновити інформацію про готель
/api/Hotel/:id	GET	Отримати інформацію про готель
/api/Room/create	POST	Створити кімнату
/api/Room/update	PUT	Оновити інформацію про кімнату
/api/Room/:id	GET	Отримати інформацію про кімнату

Продовження таблиці 1
/api/Room/:id	DELETE	Видалити кімнату
/api/Room/:roomId/roomplace	GET	Отримати місця в кімнаті
/api/Room/:roomId/roomplace/add	POST	Додати місце в кімнату
/api/Room/:roomId/roomplace/remove/:roomPlaceId	DELETE	Видалити місце з кімнати
/api/Room/:roomId/roomplace/:roomPlaceI/update	PUT	Оновити інформацію про місце в кімнаті
/api/Room/:roomId/set-api-key	POST	Встановити апі-ключ для керування замком
/api/Staff/create	POST	Створити працівника готелю
/api/Staff/:oldStaffId/tasks/:todoTaskId/reassign/:newStaffId	PUT	Переназначити задачу на іншого працівника
/api/Staff/:staffId	GET	Отримати інформацію про про працівника
/api/Staff/:staffId/remove	DELETE	Видалити працівника
/api/Staff/:staffId/tasks	GET	Отримати список задач для працівника
/api/Staff/:staffId/tasks/add	POST	Додати задачу для працівника
/api/Staff/:staffId/tasks/:todoTaskId/finish?isCompleted={isCompleted}	PUT	Завершити задачу, як виконану або невиконану
 
Продовження таблиці 1
/api/Staff/:staffId/tasks/:todoTaskId/remove	DELETE	Видалити задачу
/api/Staff/:staffId/tasks/:todoTaskId/update	PUT	Оновити задачу
/api/Staff/:staffId/update	PUT	Оновити інформацію по працівнику
/api/Stats/occupancy-report
/:hotelId	POST	Отримати помісячний звіт про наповненість та дохідність

5.4	Опис частин програмного коду

5.4.1 Реєстрація залежностей (Dependency Injections)

В даному проекту застосовується ін’єкція залежностей (Dependency Injection). Дана реалізація дозволяє розділити створення об'єктів і їхніх залежностей від їхнього використання. Це полегшує зміну та підтримку коду, оскільки залежності можна легко замінювати або розширювати без великих змін в існуючому коді. Також Dependency Injection є одним з аспектів інверсії управління, який описано в принципах SOLID. Він дозволяє контролювати, як об'єкти створюються та конфігуруються, перекладаючи ці обов'язки на контейнер інверсії управління. В проекті використано комбінований контейнер інверсії залежностей AutoFac та Microsoft Dependency Injection. Підключається контейнер AutoFac наступним чином:
1 builder.Host.UseServiceProviderFactory(factory: new AutofacServiceProviderFactory());
2builder.Host.ConfigureContainer<ContainerBuilder>(containerBuilder =>
3    containerBuilder.RegisterModule(new DiModule(configuration)));
В даному коді DiModule це написаний власноруч модуль реєстрації залежностей, він містить перевизначений (override) метод Load де виконується конфігурація залежностей:
1 protected override void Load(ContainerBuilder builder)
2    {
3        builder.RegisterGeneric(typeof(GenericRepository<>)).As(typeof(IGenericRepository<>)).InstancePerLifetimeScope();
4        builder.RegisterType<UnitOfWork>().As<IUnitOfWork>().InstancePerLifetimeScope();
5        
6        RegisterHandlers(builder);
7        
8        RegisterServiceProxies(builder);
9
10        builder.RegisterType<DbSeeder>().AsSelf().SingleInstance();
11    }
12
13    private void RegisterHandlers(ContainerBuilder builder)
14    {
15        var handlersAssembly = typeof(BLL.IAssemblyMarker).Assembly;
16        builder.RegisterAssemblyTypes(handlersAssembly)
17            .Where(t => t.Name.EndsWith("Handler"))
18            .InstancePerDependency();
19    }
20    
21    private void RegisterServiceProxies(ContainerBuilder builder)
22    {
23       builder.RegisterType<DoorLockServiceProxy.DoorLockServiceProxy>()
24           .As<IDoorLockServiceProxy>()
25           .InstancePerLifetimeScope();
26    }
В наведеному вище коді можна побачити методи розширення (Extension Methods) InstancePerDependency та InstancePerLifetimeScope. Дані методи вказують як саме буде відбуватись реєстрація залежностей. Перший метод створює новий об’єкт сервіса для кожного його використання в різних типах (класах) проекту. Наступний метод вказує нам на те, що на час обробки одного HTTP запиту буде створено один екземпляр об’єкту залежностей. Також AutoFac дозволяє використовувати відкладену ініціалізацію залежностей, тож це може стати у нагоді для навантажених компонентів системи.

5.4.2 Аутентифікація та Авторизація

В проекті аутентифікацію та авторизацію реалізовано за допомогою вбудованої системи авторизації ASP.NET Core Identity. Дана система надає гнучку і універсальну систему аутентифікації ї та авторизації за допомогою кукі та токена доступу. Також система має функціонал двух факторної авторизації. Для аутентифікації та авторизацї використовується 2 токени: токен доступу (Access Token) та токен оновлення (Refresh Token). Це дозволяє виконувати безпечну авторизацію для веб сайтів та мобільних пристроїв. Оскільки токен доступу має відносно невеликий час життя, то в HTTP-Only Cookie покладено токен оновлення, який має довший життєвий цикл і використовується тоді, коли серверу необхідно виписати новий токен доступу. Також на відміну від токена доступу, токен оновлення зберігається в базу даних. Даний механізм дозволяє виконувати безпечну і надійну авторизацію користувачів на різних пристроях та клієнтах.

5.4.3 Робота з відправкою повідомлень на пошту

Для підтвердження пошту клієнта та в майбутньому для іншого функціоналу додана сервіс відправки повідомлень на пошту. Логіку для відправки повідомлення для підтвердження адреси електронної пошти можна побачити тут, а весь код сервісу в класі EmailSenderService (додаток А): 
1public Task SendConfirmationLinkAsync(User user, string email, string confirmationLink)
2    {
3        var smtpClient = new SmtpClient(_smtpSettings.Host, _smtpSettings.Port)
4        {
5            Credentials = new NetworkCredential(_smtpSettings.SenderEmail, _smtpSettings.Password),
6            EnableSsl = _smtpSettings.EnableSsl
7        };
8        
9        var mailMessage = new MailMessage
10        {
11            From = new MailAddress(_smtpSettings.SenderEmail),
12            Subject = "HospitalityHub | Confirm your email",
13            Body = $"Please confirm your account by clicking this link: <a href='{confirmationLink}'>link</a>",
14            IsBodyHtml = true
15        };
16        
17        mailMessage.To.Add(email);
18        
19        return smtpClient.SendMailAsync(mailMessage);
20    } 

5.4.4  Робота з базою даних та транзакціями

В даному проекті для роботи з базою даних використано EF Core  який підтримує відкладене завантаження (lazy loading) як один із механізмів завантаження даних з бази даних. Lazy Loading - це техніка, при якій дані завантажуються з бази даних тільки в той момент, коли вони реально потрібні, тобто при першому зверненні до властивості, яка є навігаційною властивістю. По замовчанню дана технологія вимкнена, тому, для того, аби її застосувати необхідно додати до проекту nuget пакет Microsoft.EntityFrameworkCore.Proxies. Також при конфігуруванні контексту бази даних (додаток Б) необхідно вказати, що ми хочемо використовувати проксі для «лінивого» завантаження наступним чином:
1builder.Services.AddDbContext<ApplicationDbContext>(options =>
2{
3    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection"));
4
5    options.UseLazyLoadingProxies();
6    
7    if(builder.Environment.IsDevelopment())
8        options.UseLoggerFactory(new SerilogLoggerFactory());
9});
Наступним рішенням було використання шаблону репозиторій. Реалізовано це було за допомогою GenericRepository (додаток В), який є шаблоном реалізації репозиторію в програмуванні, який дозволяє працювати з різними типами об'єктів (сутностей) за допомогою одного та того ж самого коду. Використання GenericRepository дозволяє уникнути дублювання коду та спрощує управління даними в базі даних. Основні переваги використання GenericRepository включають зменшення повторення коду та полегшення тестування.
Також в проекті використовується шаблон UnitOfWork з імплементацію в однойменному класі (додаток Г). Даний шаблон використовується для керування транзакцією та забезпечення цілістності даних у системах баз даних. Цей шаблон забезпечує одиничну точку керування транзакцією для групи операцій з базою даних.
1public Task<IDbContextTransaction> CreateTransactionAsync()
2    {
3        return _context.Database.BeginTransactionAsync();
4    }
Даний метод створює транзакцію, а метод CommitTransaction та RollbackTransaction виконують збереження або відміну дій, зроблених в транзакції відповідно. 

5.4.5  Локалізація

Дана програмна система також підтримує українську та англійську локалізації. Для додавання локалізації використано nuget пакет Microsoft.Extensions.Localization. Конфігурацію для підтримки локалізації виконано за допомогою метода розширення в файлі LocalizationConfigExtension.cs (додаток Ґ). Локалізацію виконано за допомогою файлів ресурсів (.resx).
 
5.4.6 Глобальний обробник помилок

Для універсальної обробки помилок у програмі використовується глобальний обробник винятків, це убезпечує систему від некоректних відповідей на запити в разі серверної помилки, а також дозволяє в одному місці конфігурувати поведінку не пишучи багато зайвого і повторюваного коду, конфігурацію можна побачити тут, а весь код знаходить в файлі GlobalExceptionHandler.cs (Додаток Д): 
1public async ValueTask<bool> TryHandleAsync(
2        HttpContext httpContext,
3        Exception exception,
4        CancellationToken cancellationToken)
5    {
6        _logger.LogError(
7            exception, "Exception occurred: {Message}", exception.Message);
8
9        var problemDetails = new ProblemDetails
10        {
11            Status = StatusCodes.Status500InternalServerError,
12            Title = "Server error",
13            Detail = exception.Message + exception.InnerException?.Message
14        };
15
16        httpContext.Response.StatusCode = problemDetails.Status.Value;
17
18        await httpContext.Response
19            .WriteAsJsonAsync(problemDetails, cancellationToken);
20
21        return true; 
6 ІОТ ПРИСТРІЙ

6.1	Опис прийнятих інженерних рішень

IOT частина проекту розроблена на основі мікроконтролера Espressif ESP32, що базується на архітектурі Xtensa LX6. Продається як в двоядерних варіаціях, так і одноядерних. Перевагами даного мікроконтролеру являється наявність вбудованого WI-FI та Bluetooth (low-energy) з великою кількістю пінів (32 піни) для підключення зовнішніх пристроїв. Для симуляції роботи даного мікроконтролера використано платформу Wokwi та PlatformIO IDE розширення для VS Code, що надає можливості гнучкого управління бібліотеками, які використовуються на проекті та надає можливості компіляції коду. Мовою програмування обрано C++, оскільки саме на цій мові написана найбільша кількість бібліотек під платформу ESP32. Серед зовнішніх пристроїв використано клавіатуру Keypad 3*4 для вводу цифр вводу 0 до 9 та з наявністю кнопок «*» та «#», які використовуються для підтвердження вводу та скиду набраних цифр до значення по замовченню. Також використано серво привід для імітації відкриття та закриття замку дверей, Також для індикації відкриття дверей та індикації режиму адміністратора додано світлодіоди: червоний та зелений.
 
 
Рисунок 6.1 – Схема будови ІОТ пристрою

6.2	Діаграми

Першою пропоную розглянути діаграму активності IOT пристрою для програмної система для керування готелем (додаток Е).
Наступною діаграмою є діаграма взаємодії системи (додаток Є). На ній продемонстровані основні сценарії взаємодії компонентів системи.
Наступним кроком будо складено Use-Case діаграму (рис. 6.2) для відображення можливих сценаріїв дій для користувачів системи. Передбачено, що система має 3 користувачів: менеджера системи, гостя та адміністратора. Також варто зазначити, що в середині системи у різних користувачів крім адміністратора може бути різний доступ до різних функцій.
 
Рисунок 6.2 – Use-Case діаграма можливих сценаріїв використання системи для різних користувачів 

Далі пропоную ознайомитись з діаграмою станів (State Diagram), яка різноманітні стани IOT системи (рис. 6.3) та перехід з одного стану в інший.

 
Рисунок 6.3 – State Diagram, діаграма станів системи
6.3	Пояснення програмного коду

6.3.1 Аутентифікація

В проекті аутентифікацію реалізовано за допомогою API-ключа, який передається в заголовку запиту з назвою «x-api-key». Встановлення ключа можна побачити в наступному фрагменті коду:
1server.on("/set-api-key", HTTP_POST, [](AsyncWebServerRequest* request) {
2    if (isAdmin) {
3      apiKey = request->getParam("api-key")->value();
4      request->send(200, "text/plain", "true");
5    } else {
6      request->send(403, "text/plain", "Forbidden");
7    }
8  });
Апі ключ перевіряється при встановленні в початкове значення коду доступу для замка, так наприклад, як от в методі встановлення коду:
1server.on("/set-doorlock-code", HTTP_POST, [](AsyncWebServerRequest* request) {
2  String apiKeyHeader = request->header("x-api-key");
3  if (apiKeyHeader == apiKey) {
4    String newCode = request->getParam("code")->value();
5    roomAccessCode = newCode;
6    request->send(200, "text/plain", "true");
7  }
8  else {
9    request->send(401, "text/plain", "Unauthorized");
10  }
11});


Для встановлення значення ключа передбачено режим адміністратора, який включається за допомогою введення коду або прикладання карти адміністратора. Далі для встановлення значення ключа необхідно відправити запит на адресу «set-api-key» з параметром запиту «api-key» із бажаним значення ключа для подальшої роботи. Після слід вимкнути режим адміністратора натиснувши кнопку «*» і далі можна продовжити користуватись замком.

6.3.2 Робота з сервомотором та світлодіодом

Робота з сервомотором потрібна для емуляції роботи замку дверей. Робота з сервомотором відбувається в методах блокування та розблокування замку дверцят. Для конфігурації необхідно вказати номер піну по якому будуть надсилатись команди та в методі setup виконати команду attach, для якої в якості аргумента функції передати змінну піна сервомотору. Переглянути код конфігурування даних компонентів можна в додатку В.

6.3.3 Робота з клавіатурою для введення цифр (Keypad)

Клавіатура з 10 цифрами та кнопками (далі кейпад) «*» та «#» є основним інтерфейсом взаємодії і потрібна для емуляції роботи замку дверей. Конфігурація відбувається наступним чином: 
1const uint8_t ROWS = 4;
2const uint8_t COLS = 3;
3char keys[ROWS][COLS] = {
4  { '1', '2', '3' },
5  { '4', '5', '6' },
6  { '7', '8', '9' },
7  { '*', '0', '#' }
8};
9
10uint8_t colPins[COLS] = { 21, 22, 23 }; // Pins connected to C1, C2, C3
11uint8_t rowPins[ROWS] = { 19, 18, 17, 4 }; // Pins connected to R1, R2, R3, R4
12
13Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
Далі в методі loop() будемо викликати метод processKeypadSequence(), в якому будемо зчитувати натискання на клавіатуру, та виконувати операції по порівнянню коду доступу, переходу в режим адміністратора та скидання набраної послідовності до по замовчуванню: 
1void processKeypadSequence(bool* isAdmin)
2{
3  char key = keypad.getKey();
4
5  if (key == NO_KEY) {
6    return;
7  }
8
9  if (key == '#')
10  {
11    Serial.println("Checking password");
12
13    if (checkPassword(keyPadSequence, adminPassword))
14    {
15      *isAdmin = true;
16      Serial.println("Admin mode activated");
17    }
18    else if (checkPassword(keyPadSequence, _roomAccessCode))
19    {
20      unlockDoor();
21    }
22    else
23    {
24      lockDoor();
25    }
26
27    keyPadSequence = new String("");
28  }
29  else if (key == '*')
30  {
31    if (*isAdmin)
32    {
33      *isAdmin = false;
34      Serial.println("Admin mode deactivated");
35    }
36    lockDoor();
37    keyPadSequence = new String("");
38  }
39  else
40  {
41    *keyPadSequence += key;
42  }
43
44}


 
7 КЛІЄНТСЬКА ЧАСТИНА

7.1	 Опис прийнятих інженерних рішень

Клієнтська частина проекту розроблена за допомогою фреймворку Angular 16 з використанням мови TypeScript. Також для розробки інтерфейсу було використано компоненти Angular Material. Для розробки було використано IDE JetBrains WebStorm та редактор Visual Studio Code. Для виконання асинхронних запитів на API та відстежування змін моделей було використано бібліотеку Rx.js. Також на проекті реалізовано аутентифікації та авторизації за допомогою JWT токенів, як токенів доступу та токена в HTTP-Only Cookie для оновлення токену доступу.
Клієнтська частина має монолітну багатомодульну архітектуру [3], а також застосовано підхід screaming features, в якому кожен модуль відповідає за свою бізнес-логіку та представлення даних.  Також оркемо виділено модуль з сервісами для запитів на API та контрактних моделей. Також для пришвидшення розробки наявний інструментально згенерований модуль «api-proxy», де згенеровано сервіси та контракти, базуючись на описі Open-API серверної частини.
Основний елемент взаємодії користувача – це таблиці з відображенням даних (рис. 7.1) та відповідними методами взаємодії, такими, як створення даних, редагування та видалення.

 
Рисунок 7.1 – Приклад таблиці

Для створення даних було додано відповідні модальні вікна, як наприклад, на рис. 7.2, або для деяких сутностей було створено окремі сторінки з детальною інформацією, як на рис. 7.3.

 
Рисунок 7.2 – Приклад модального вікна з формою для заповнення даних

 
Рисунок 7.3 – Приклад сторінки з формою для редагування та перегляду детальної інформації

7.2	Діаграми

Першою було складено діаграму розгортання системи (рис. 7.4), яка включає в себе такі компоненти: серверна частина (API), БД, клієнтська частина. Систему розгорнуто в контейнерах Docker. Розгортання системи в Docker дозволяє створювати ізольовані контейнери з усіма необхідними залежностями, що забезпечує однакове середовище для розробки, тестування та продакшену. Це сприяє кращій масштабованості, портативності та швидкому розгортанню додатків, знижуючи ризик проблем, пов'язаних з несумісністю середовища. 
Рисунок 7.4 – Діаграма розгортання системи для керування готелем

Наступним кроком будо складено Use-Case діаграму (рис. 7.5) для відображення можливих сценаріїв дій для користувачів системи. Передбачено, що система має 3 користувача: менеджер, персонал та адміністратора. Також варто зазначити, що в середині системи у різних користувачів крім адміністратора може бути різний доступ до різних функцій. Також було складено діаграму станів системи (рис. )
 
Рисунок 7.5 – Use-Case діаграма можливих сценаріїв використання системи для різних користувачів 

 
Рис 7.6 – Діаграма станів системи
Далі пропоную ознайомитись з діаграмою пакетів (Package-Diagram), яка показує залежності різних модулів архітектури (рис. 7.7) та взаємодію компонентів:
 
Рисунок 7.7 – Package Diagram, діаграма залежностей архітектури

7.3	Опис частин програмного коду

7.3.1 Реєстрація залежностей (Dependency Injections)

В даному проекту застосовується ін’єкція залежностей (Dependency Injection). Дана реалізація дозволяє розділити створення об'єктів і їхніх залежностей від їхнього використання. Це полегшує зміну та підтримку коду, оскільки залежності можна легко замінювати або розширювати без великих змін в існуючому коді. Також Dependency Injection є одним з аспектів інверсії управління, який описано в принципах SOLID. Він дозволяє контролювати, як об'єкти створюються та конфігуруються, перекладаючи ці обов'язки на контейнер інверсії управління. Angular 16 пропонує користувачу власний контейнер залежностей R3, який дозволяє реєструвати залежності наступним чином:

1@Injectable({
2  providedIn: 'root'
3})
4
5export class AccountService {
6
7  private readonly baseUrl = environment.apiUrl + "/account";
8
9  constructor(private readonly http: HttpClient) {
10  }
11 …

7.3.2 Аутентифікація та Авторизація

Для аутентифікації та авторизацї використовується 2 токени: токен доступу (Access Token) та токен оновлення (Refresh Token). Токен доступу являє собою JWT (Json Web Token) – це спеціальний токен, який складається з 3 частин: заголовку, тіла та підпису верифікації. Це дозволяє виконувати авторизацію для веб сайтів та мобільних пристроїв. Оскільки токен доступу має відносно невеликий час життя, то в HTTP-Only Cookie покладено токен оновлення, який має довший життєвий цикл і використовується тоді, коли серверу необхідно виписати новий токен доступу. Також на відміну від токена доступу, токен оновлення зберігається в базу даних. Даний механізм дозволяє виконувати безпечну і надійну авторизацію користувачів на різних пристроях та клієнтах.
7.3.3 Локалізація

Дана програмна система також підтримує українську та англійську локалізації. Для додавання локалізації використано npm пакету ngx/translate. Конфігурацію для підтримки локалізації виконано в файлі app.module.ts (додаток Ж). Локалізацію виконано за допомогою файлів ресурсів перекладів (.json). Даний пакет дозволяє нам використовувати pipe «translate» для виконання перекладів:
1<ng-container matColumnDef="number">
2      <th mat-header-cell *matHeaderCellDef>{{ 'number' | translate }}</th>
3      <td mat-cell *matCellDef="let element"> {{ element.number }}</td>
4    </ng-container>



 
ВИСНОВКИ

Результатом виконання даної курсової роботи є створена програмна інформаційної системи для керування роботою. Дана програмна система надає користувачам наступний перелік можливостей: аутентифікація та авторизація користувачів, реєстрація нових користувачів. В системі передбачено можливість розподілення доступу до функцій на основі ролей. Також в системі наявний функціонал для перегляду, створення, редагування та видалення готелів, кімнат в готелях, місць в кімнатах, ролей, персоналу, задач для персоналу, клієнтів та бронювання. Також система може надавати статистику для перегляду основних статистичних показників  з відображенням цих даних помісячно за обраний період. В септимі також наявний функціонал керування дверними замками, з можливостями захищеної відправки команд на IoT пристрої, встановлення коду доступу до кімнати та режиму адміністратора на пристрої.
Розробляючи інформаційну систему було проаналізовано відповідну предметну область, проведено її концептуальне, інфологічне та логічне моделювання, спроектовано та реалізовано відповідну реляційну базу даних. Крім того, було закріплено набути теоретичні та практичні навички з архітектура програмного забезпечення, що дозволить застосовувати їх в майбутньому.
Середовищем для розробки програмного забезпечення даної інформаційної системи обрано наступні інструменти: Visual Studio Community 2022 та JetBrains Rider, JetBrains WebStorm та Visual Studio Code. Для програмування серверної частини обрано мову C# та платформу .NET 8. Основним фреймворком для створення серверної частини обрано ASP.NET Web API. Для доступу до БД було використано Entity Framework Core. В якості СУБД обрано PostgreSQL 16.2. Клієнтська частина була створена засобами фреймворку Angular 16 та мови програмування TypeScript. Для виконання частини з IoT пристроєм використано плату мікроконтролера ESP 32 та мову програмування C++.
Програмна система спроектована для можливості швидкого та зручного розширення функціоналу. Система має потенціал для розвитку і можливості стати потужним інструментом для автоматизації готельного бізнесу. Одним з розширень, для використання вже наявного функціоналу може стати розробка мобільного застосунку для персоналу готелю, для відслідковування задач та контролю за їх виконанням.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	Лупашко А. На початку війни готельний бізнес україни обвалився на 90%. чи є надія на відновлення – forbes.ua. Forbes.ua | Бізнес, мільярдери, новини, фінанси, інвестиції, компанії. URL: https://forbes.ua/company/na-pochatku-viyni-gotelniy-biznes-ukraini-obvalivsya-na-90-chi-e-nadiya-na-vidnovlennya-14102022-9033 (дата звернення: 22.06.2024).
2.	Bob Code. Repository pattern C# ultimate guide: entity framework core, clean architecture, dtos, dependency injection, CQRS. Medium. URL: https://medium.com/@codebob75/repository-pattern-c-ultimate-guide-entity-framework-core-clean-architecture-dtos-dependency-6a8d8b444dcb (дата звернення: 22.06.2024).
3.	How to build a modular webApp using Angular Modules and NgModule?.  Medium. URL: https://medium.com/@abdoessamadhmayda/how-to-build-a-modular-webapp-using-angular-modules-and-ngmodule-7d0452ad8323 (дата звернення: 22.06.2024).
4.	GitHub - NureMerkulovArsenii/apzkr-pzpi-21-3-merkulov-arsenii. GitHub. URL: https://github.com/NureMerkulovArsenii/apzkr-pzpi-21-3-merkulov-arsenii (дата звернення: 22.06.2024).
5.	Арсеній Меркулов. Apzkr-pzpi-21-3-merkulov-arsenii, 2024. YouTube. URL: https://www.youtube.com/watch?v=du1nSH4WtDI (дата звернення: 22.06.2024).
 
ДОДАТОК А
Результат перевірки на плагіат

 
 
ДОДАТОК Б
EmailSender.cs

1public class EmailSender : IEmailSender<User>
2{
3    private readonly SmtpSettings _smtpSettings;
4
5    public EmailSender(IConfiguration configuration)
6    {
7        _smtpSettings = new SmtpSettings()
8        {
9            Host = configuration["SmtpSettings:Host"],
10            Password = configuration["SmtpSettings:Password"],
11            Port = configuration.GetValue<int>("SmtpSettings:Port"),
12            EnableSsl = configuration.GetValue<bool>("SmtpSettings:EnableSsl"),
13            UseDefaultCredentials = configuration.GetValue<bool>("SmtpSettings:UseDefaultCredentials"),
14            SenderEmail = configuration["SmtpSettings:SenderEmail"],
15        };
16    }
17    
18    public Task SendConfirmationLinkAsync(User user, string email, string confirmationLink)
19    {
20        var smtpClient = new SmtpClient(_smtpSettings.Host, _smtpSettings.Port)
21        {
22            Credentials = new NetworkCredential(_smtpSettings.SenderEmail, _smtpSettings.Password),
23            EnableSsl = _smtpSettings.EnableSsl
24        };
25        
26        var mailMessage = new MailMessage
27        {
28            From = new MailAddress(_smtpSettings.SenderEmail),
29            Subject = "HospitalityHub | " + Resources.Get("CONFIRM_YOUR_EMAIL"),
30           Body = string.Format(Resources.Get("CONFIRM_YOUR_ACCOUNT"), confirmationLink),
31            IsBodyHtml = true
32        };
33        
34        mailMessage.To.Add(email);
35        
36        return smtpClient.SendMailAsync(mailMessage);
37    }
38
39    public Task SendPasswordResetLinkAsync(User user, string email, string resetLink)
40    {
41        var smtpClient = new SmtpClient(_smtpSettings.Host, _smtpSettings.Port)
42        {
43            Credentials = new NetworkCredential(_smtpSettings.SenderEmail, _smtpSettings.Password),
44            EnableSsl = _smtpSettings.EnableSsl
45        };
46        
47        var mailMessage = new MailMessage
48        {
49            From = new MailAddress(_smtpSettings.SenderEmail),
50            Subject = "HospitalityHub | " + Resources.Get("RESET_YOUR_PASSWORD"),
51            Body = string.Format(Resources.Get("RESET_YOUR_PASSWORD_LINK_MESSAGE"), resetLink),
52            IsBodyHtml = true
53        };
54        
55        mailMessage.To.Add(email);
56        
57        return smtpClient.SendMailAsync(mailMessage);
58        
59    }
60
61    public Task SendPasswordResetCodeAsync(User user, string email, string resetCode)
62    {
63        var smtpClient = new SmtpClient(_smtpSettings.Host, _smtpSettings.Port)
64        {
65            Credentials = new NetworkCredential(_smtpSettings.SenderEmail, _smtpSettings.Password),
66            EnableSsl = _smtpSettings.EnableSsl
67        };
68        
69        var mailMessage = new MailMessage
70        {
71            From = new MailAddress(_smtpSettings.SenderEmail),
72            Subject = "HospitalityHub | " + Resources.Get("RESET_YOUR_PASSWORD"),
73            Body = string.Format(Resources.Get("RESET_YOUR_PASSWORD_CODE_MESSAGE"), resetCode),
74            IsBodyHtml = true
75        };
76        
77        mailMessage.To.Add(email);
78        
79        return smtpClient.SendMailAsync(mailMessage);
80    }
81}
 
ДОДАТОК В
ApplicationDbContext.cs

1public class ApplicationDbContext : IdentityDbContext<User, IdentityRole<int>, int>
2{
3    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options)
4    {
5    }
6
7    public DbSet<User> User { get; set; }
8
9    public DbSet<Hotel> Hotel { get; set; }
10
11    public DbSet<Room> Room { get; set; }
12
13    public DbSet<Booking> Booking { get; set; }
14
15    public DbSet<RoomPlace> RoomPlace { get; set; }
16
17    public DbSet<Photo> Photo { get; set; }
18
19    public DbSet<TodoTask> TodoTasks { get; set; }
20    
21    public DbSet<Customer> Customer { get; set; }
22    
23    public DbSet<Staff> Staff { get; set; }
24
25    public override Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess,
26        CancellationToken cancellationToken = new())
27    {
28        var entries = ChangeTracker
29            .Entries()
30            .Where(e => e is { Entity: BaseEntity, State: EntityState.Added or EntityState.Modified });
31
32        foreach (var entityEntry in entries)
33        {
34            ((BaseEntity)entityEntry.Entity).DateUpdated = DateTime.Now;
35
36            if (entityEntry.State == EntityState.Added)
37            {
38                ((BaseEntity)entityEntry.Entity).DateCreated = DateTime.Now;
39            }
40        }
41
42        return base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
43    }
44
45    protected override void OnModelCreating(ModelBuilder builder)
46    {
47        builder.Entity<User>()
48            .HasKey(x => x.Id);
49        
50        base.OnModelCreating(builder);
51    }
52}

 
ДОДАТОК Г
GenericRepository.cs

1public class GenericRepository<TEntity> : IGenericRepository<TEntity> where TEntity : class, IBaseEntity
2{
3    private readonly ApplicationDbContext _appContext;
4
5    public GenericRepository(ApplicationDbContext appContext)
6    {
7        _appContext = appContext;
8    }
9
10    /// <inheritdoc />
11    public IQueryable<TEntity> GetAll()
12    {
13        var entities = _appContext.Set<TEntity>().AsQueryable();
14        return entities;
15    }
16
17    /// <inheritdoc />
18    public IQueryable<TEntity> GetAllByCondition(Expression<Func<TEntity, bool>> predicate)
19    {
20        var entities = _appContext.Set<TEntity>().AsQueryable().Where(predicate);
21        return entities;
22    }
23
24    /// <inheritdoc />
25    public async Task<TEntity> FirstOrDefaultAsync(Expression<Func<TEntity, bool>> predicate,
26        CancellationToken cancellationToken = default)
27    {
28        return await _appContext.Set<TEntity>().FirstOrDefaultAsync(predicate, cancellationToken);
29    }
30
31    /// <inheritdoc />
32    public TEntity FirstOrDefault(Expression<Func<TEntity, bool>> predicate)
33    {
34        return _appContext.Set<TEntity>().FirstOrDefault(predicate);
35    }
36
37
38    /// <inheritdoc />
39    public async Task<TEntity> GetByIdAsync<T>(T id)
40    {
41        return await _appContext.Set<TEntity>().FindAsync(id);
42    }
43
44    /// <inheritdoc />
45    public async Task<IList<TEntity>> GetByConditionAsync(
46        Expression<Func<TEntity, bool>> predicate,
47        Expression<Func<TEntity, TEntity>> selector = null,
48        CancellationToken cancellationToken = default)
49    {
50        IQueryable<TEntity> query = _appContext.Set<TEntity>().AsQueryable();
51
52        if (selector != null)
53        {
54            query = query
55                .Where(predicate)
56                .Select(selector);
57        }
58        else
59        {
60            query = query.Where(predicate);
61        }
62
63        return await query.ToListAsync(cancellationToken: cancellationToken);
64    }
65
66    /// <inheritdoc />
67    public async Task<bool> ExistAsync(
68        Expression<Func<TEntity, bool>>? predicate = null,
69        CancellationToken cancellationToken = default)
70    {
71        if (predicate is not null)
72        {
73            return await _appContext.Set<TEntity>().AnyAsync(predicate, cancellationToken);
74        }
75
76        return await _appContext.Set<TEntity>().AnyAsync(cancellationToken);
77    }
78
79    /// <inheritdoc />
80    public async Task AddAsync(TEntity obj, CancellationToken cancellationToken = default)
81    {
82        await _appContext.Set<TEntity>().AddAsync(obj, cancellationToken: cancellationToken);
83    }
84
85    /// <inheritdoc />
86    public void Add(TEntity obj)
87    {
88        _appContext.Set<TEntity>().Add(obj);
89    }
90
91    /// <inheritdoc />
92    public async Task AddRangeAsync(IEnumerable<TEntity> obj, CancellationToken cancellationToken = default)
93    {
94        await _appContext.Set<TEntity>().AddRangeAsync(obj, cancellationToken: cancellationToken);
95    }
96
97    /// <inheritdoc />
98    public void AddRange(IEnumerable<TEntity> entities)
99    {
100        _appContext.Set<TEntity>().AddRange(entities);
101    }
102
103    /// <inheritdoc />
104    public void Update(TEntity obj)
105    {
106        _appContext.Set<TEntity>().Entry(obj).State = EntityState.Modified;
107        //_dbSet.Update(obj);
108    }
109
110    /// <inheritdoc />
111    public void UpdateRange(IEnumerable<TEntity> entities)
112    {
113        _appContext.Set<TEntity>().UpdateRange(entities);
114    }
115
116    /// <inheritdoc />
117    public void Delete(TEntity obj)
118    {
119        try
120        {
121            _appContext.Set<TEntity>().Remove(obj);
122        }
123        catch (Exception e)
124        {
125            Console.WriteLine(e);
126            throw;
127        }
128    }
129
130    /// <inheritdoc />
131    public async Task<int> DeleteAsync(
132        Expression<Func<TEntity, bool>> predicate,
133        CancellationToken cancellationToken = default)
134    {
135        var entities = _appContext.Set<TEntity>().Where(predicate);
136        var deletedRows = await entities.ExecuteDeleteAsync(cancellationToken);
137
138        return deletedRows;
139    }
140
141    /// <inheritdoc />
142    public async Task<int> ExecuteDeleteAsync(Expression<Func<TEntity, bool>> predicate,
143        CancellationToken cancellationToken = default)
144    {
145        var entities = _appContext.Set<TEntity>().Where(predicate);
146
147        var deletedRowsCount = await entities.ExecuteDeleteAsync(cancellationToken);
148
149        return deletedRowsCount;
150    }
151
152    /// <inheritdoc />
153    public async Task<int> ExecuteUpdateAsync(Expression<Func<TEntity, bool>> predicate,
154        Expression<Func<SetPropertyCalls<TEntity>, SetPropertyCalls<TEntity>>> setPropertyCalls,
155        CancellationToken cancellationToken = default)
156    {
157        var entities = _appContext.Set<TEntity>().Where(predicate);
158        var updatedRowsCount = await entities.ExecuteUpdateAsync(setPropertyCalls, cancellationToken);
159
160        return updatedRowsCount;
161    }
162}
 
ДОДАТОК Ґ
UnitOfWork.cs

1public class UnitOfWork : IUnitOfWork
2{
3    private readonly Lazy<IGenericRepository<Room>> _roomRepository;
4    private readonly Lazy<IGenericRepository<Booking>> _bookingRepository;
5    private readonly Lazy<IGenericRepository<Hotel>> _hotelRepository;
6    private readonly Lazy<IGenericRepository<Photo>> _photoRepository;
7    private readonly Lazy<IGenericRepository<RoomPlace>> _roomPlaceRepository;
8    private readonly Lazy<IGenericRepository<TodoTask>> _todoTaskRepository;
9    private readonly Lazy<IGenericRepository<Customer>> _customerRepository;
10    private readonly Lazy<IGenericRepository<Staff>> _staffRepository;
11    private readonly ApplicationDbContext _context;
12
13    public UnitOfWork(
14        Lazy<IGenericRepository<Room>> roomRepository,
15        Lazy<IGenericRepository<Booking>> bookingRepository,
16        Lazy<IGenericRepository<Hotel>> hotelRepository,
17        Lazy<IGenericRepository<Photo>> photoRepository,
18        Lazy<IGenericRepository<RoomPlace>> roomPlaceRepository,
19        Lazy<IGenericRepository<TodoTask>> todoTaskRepository,
20        Lazy<IGenericRepository<Customer>> customerRepository,
21        Lazy<IGenericRepository<Staff>> staffRepository,
22        ApplicationDbContext context)
23    {
24        _roomRepository = roomRepository;
25        _bookingRepository = bookingRepository;
26        _hotelRepository = hotelRepository;
27        _photoRepository = photoRepository;
28        _roomPlaceRepository = roomPlaceRepository;
29        _todoTaskRepository = todoTaskRepository;
30        _customerRepository = customerRepository;
31        _staffRepository = staffRepository;
32        _context = context ?? throw new ArgumentNullException(nameof(context));
33    }
34
35    public IGenericRepository<Booking> BookingRepository => _bookingRepository.Value;
36    public IGenericRepository<Hotel> HotelRepository => _hotelRepository.Value;
37    public IGenericRepository<Room> RoomRepository => _roomRepository.Value;
38    public IGenericRepository<Photo> PhotoRepository => _photoRepository.Value;
39    public IGenericRepository<RoomPlace> RoomPlaceRepository => _roomPlaceRepository.Value;
40    public IGenericRepository<TodoTask> TodoTaskRepository => _todoTaskRepository.Value;
41    public IGenericRepository<Customer> CustomerRepository => _customerRepository.Value;
42    public IGenericRepository<Staff> StaffRepository => _staffRepository.Value;
43
44
45    public Task<IDbContextTransaction> CreateTransactionAsync()
46    {
47        return _context.Database.BeginTransactionAsync();
48    }
49
50    public IDbContextTransaction CreateTransaction()
51    {
52        return _context.Database.BeginTransaction();
53    }
54
55    public Task CommitTransactionAsync()
56    {
57        return _context.Database.CommitTransactionAsync();
58    }
59
60    public void CommitTransaction()
61    {
62        _context.Database.CommitTransaction();
63    }
64
65    public Task RollbackTransactionAsync()
66    {
67        if (_context.Database.CurrentTransaction != null)
68            return _context.Database.RollbackTransactionAsync();
69
70        return Task.CompletedTask;
71    }
72
73    public void RollbackTransaction()
74    {
75        if (_context.Database.CurrentTransaction != null)
76            _context.Database.RollbackTransaction();
77    }
78
79    public async Task SaveAsync()
80    {
81        await _context.SaveChangesAsync();
82
83        _context.Database.CurrentTransaction?.Dispose();
84    }
85
86    public void Save()
87    {
88        _context.SaveChanges();
89
90        _context.Database.CurrentTransaction?.Dispose();
91    }
92
93    public async Task ExecuteSqlRawAsync(string sql, params object[] parameters)
94    {
95        await _context.Database.ExecuteSqlRawAsync(sql, parameters);
96    }
97}
 
ДОДАТОК Д
Метод розширення для додавання локалізації запитів в LocalizationConfigExtension.cs

1internal static void ConfigureLocalization(this IServiceCollection services, IConfiguration configuration)
2    {
3        services.AddLocalization(x => x.ResourcesPath = "Resources");
4        
5        var supportedCultures = new[]
6        {
7            new CultureInfo("en-US"),
8            new CultureInfo("uk-UA")
9        };
10        
11        services.Configure<RequestLocalizationOptions>(options =>
12        {
13            options.DefaultRequestCulture = new RequestCulture("en-US", "en-US");
14            options.SupportedCultures = supportedCultures;
15            options.SupportedUICultures = supportedCultures;
16        
17            options.RequestCultureProviders = new List<IRequestCultureProvider>
18            {
19                new AcceptLanguageHeaderRequestCultureProvider()
20            };
21        });
22
23    }
 
ДОДАТОК Е
Глобальний обробник помилок LocalizationConfigExtension.cs

1public class GlobalExceptionHandler : IExceptionHandler
2{
3    private readonly ILogger<GlobalExceptionHandler> _logger;
4
5    public GlobalExceptionHandler(ILogger<GlobalExceptionHandler> logger)
6    {
7        _logger = logger;
8    }
9    
10    public async ValueTask<bool> TryHandleAsync(
11        HttpContext httpContext,
12        Exception exception,
13        CancellationToken cancellationToken)
14    {
15        _logger.LogError(
16            exception,  Resources.Get("UNEXPECTED_EXCEPTION_OCCURED"), exception.Message);
17        
18
19        var problemDetails = new ProblemDetails
20        {
21            Status = StatusCodes.Status500InternalServerError,
22            Title = "Internal Server Error",
23            Detail = exception.Message + exception.InnerException?.Message
24        };
25
26        httpContext.Response.StatusCode = problemDetails.Status.Value;
27
28        await httpContext.Response
29            .WriteAsJsonAsync(problemDetails, cancellationToken);
30
31        return true;
32    }
33}
 
ДОДАТОК Є
Діаграма діяльності IoT пристрою для програмної системи

 
 
ДОДАТОК Ж
Діаграма взаємодії IoT пристрою для програмної системи 

  
 
ДОДАТОК З
Файл «app.module.ts» з налаштуванням інтернаціоналізації та локалізації

1import {NgModule} from '@angular/core';
2import {BrowserModule} from '@angular/platform-browser';
3
4import {AppRoutingModule} from './app-routing.module';
5import {AppComponent} from './app.component';
6import {NgbModule} from '@ng-bootstrap/ng-bootstrap';
7import {ApiModule} from "./api-proxy/api.module";
8import {environment} from "../environments/environment";
9import {HTTP_INTERCEPTORS, HttpClient, HttpClientModule} from "@angular/common/http";
10import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
11import {SharedModule} from "./shared/shared.module";
12import {TranslateLoader, TranslateModule} from "@ngx-translate/core";
13import {TranslateHttpLoader} from "@ngx-translate/http-loader";
14import {FontAwesomeModule} from '@fortawesome/angular-fontawesome';
15import {ToastrModule} from "ngx-toastr";
16import {MAT_DIALOG_DEFAULT_OPTIONS} from "@angular/material/dialog";
17import {I18nInterceptor} from "./core/interceptors/i18n.interceptor";
18import {BearerTokenInterceptor} from "./core/interceptors/bearer-token.interceptor";
19import { MAT_DATE_LOCALE, MatNativeDateModule } from '@angular/material/core';
20import { MatDatepickerModule } from '@angular/material/datepicker';
21
22export function HttpLoaderFactory(http: HttpClient) {
23  return new TranslateHttpLoader(http, './assets/i18n/', '.json');
24}
25
26@NgModule({
27  declarations: [
28    AppComponent
29  ],
30  imports: [
31    BrowserModule,
32    AppRoutingModule,
33    NgbModule,
34    HttpClientModule,
35    ApiModule.forRoot({rootUrl: environment.apiUrl}),
36    BrowserAnimationsModule,
37    SharedModule,
38    TranslateModule.forRoot({
39      defaultLanguage: 'en',
40      loader: {
41        provide: TranslateLoader,
42        useFactory: HttpLoaderFactory,
43        deps: [HttpClient],
44      }
45    }),
46    FontAwesomeModule,
47    ToastrModule.forRoot(
48      {
49        timeOut: 4000,
50        positionClass: 'toast-bottom-right',
51        preventDuplicates: true,
52      }
53    ),
54    MatDatepickerModule,
55    MatNativeDateModule 
56  ],
57  providers: [
58    {provide: MAT_DIALOG_DEFAULT_OPTIONS, useValue: {hasBackdrop: false,}},
59    {provide: HTTP_INTERCEPTORS, useClass: I18nInterceptor, multi: true},
60    {provide: HTTP_INTERCEPTORS, useClass: BearerTokenInterceptor, multi: true},
61    {provide: MAT_DATE_LOCALE, useValue: 'uk-UA'},
62  ],
63  bootstrap: [AppComponent]
64})
65export class AppModule {
66}
67



